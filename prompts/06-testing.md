# Testing Prompts

## Unit Test Generation
```
Generate unit tests for this function:
{paste function}

Create tests for:
- Happy path scenarios
- Edge cases
- Error conditions
- Boundary values
Use {testing framework} and include mocks where necessary.
```

## Test Case Design
```
Design comprehensive test cases for:
{describe functionality or paste code}

Include:
- Test case description
- Input data
- Expected output
- Preconditions
- Postconditions
Cover positive, negative, and edge cases.
```

## Integration Test
```
Create integration tests for:
{describe system components to test}

Test:
- Component interactions
- Data flow between components
- Error propagation
- External dependencies (mocked)
Use {testing framework}.
```

## End-to-End Test
```
Write end-to-end tests for this user flow:
{describe user flow}

Include:
- Setup and teardown
- Step-by-step user actions
- Assertions at each step
- Cleanup
Use {E2E testing framework}.
```

## Test Data Generation
```
Generate test data for:
{describe what needs testing}

Create:
- Valid input samples
- Invalid input samples
- Edge case data
- Boundary value data
Format: {specify format}
```

## Mock Creation
```
Create mocks for:
{describe external dependencies}

For testing:
{describe what's being tested}

Include:
- Mock implementation
- Expected call patterns
- Return values for different scenarios
Use {mocking framework}.
```

## Performance Test
```
Create a performance test for:
{paste code or describe functionality}

Measure:
- Execution time
- Memory usage
- Throughput
- Resource utilization
Set performance benchmarks and assertions.
```

## Test Refactoring
```
Refactor these tests to be more maintainable:
{paste test code}

Improve:
- Remove duplication
- Improve readability
- Better test organization
- Clearer assertions
- Setup/teardown optimization
```
